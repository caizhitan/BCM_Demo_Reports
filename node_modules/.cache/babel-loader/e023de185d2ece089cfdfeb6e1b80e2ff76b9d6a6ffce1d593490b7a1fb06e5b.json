{"ast":null,"code":"import dayjs from \"dayjs\";\nimport bigDecimal from \"js-big-decimal\"; // Excel uses HALF-UP Rounding\nimport { formatDateDayJS, formatLeaseFeeDetailsDateDayJS, formatDateForDuration, formatDateForTransactions, formatDateForVO } from \"../../FormatDate\";\nimport { BusData } from \"../../DummyData\";\nimport { roundGrandTotal1000 } from \"../../RoundingRules\";\n//test\n// Function to extract data specifically for User Selected Service\nfunction findServiceData(dataSet, selectedService, isLeaseFee = false) {\n  if (isLeaseFee) {\n    for (const contract in dataSet) {\n      if (dataSet[contract][selectedService]) {\n        return dataSet[contract][selectedService] || null;\n      }\n    }\n  } else {\n    // For all other Data values\n    for (const contract in dataSet) {\n      if (dataSet[contract][selectedService]) {\n        return dataSet[contract][selectedService];\n      }\n    }\n    return null;\n  }\n}\n\n// This Function handles 3 conditions. A: Only Bus Fleet Values | B: Bus Fleet and Contract Values Match | C: Only Contract Values\n// Condition B happens when Bus Fleet & Contract Implementation Start and End date are the same.\nfunction checkBusFleet(BusData) {\n  const results = {};\n\n  // Loop through Bus Fleet Data first\n  BusData.body.busFleet.forEach(fleet => {\n    if (!results[fleet.contract]) {\n      results[fleet.contract] = {};\n    }\n    fleet.values.forEach(service => {\n      const [startDate, endDate] = service.Implementation[0].split(\"-\");\n      const busFleetKey = `${service.Service}_${startDate}_${endDate}`;\n\n      // Initialize bus fleet entry if it doesn't exist\n      if (!results[fleet.contract][busFleetKey]) {\n        results[fleet.contract][busFleetKey] = {\n          onlyBusFleet: true,\n          isMatch: false,\n          onlyContract: false,\n          BusFleet: {\n            Transaction: service.Transaction,\n            Implementation: service.Implementation\n          },\n          // Default values for onlyBusFleet\n          values: [{\n            TotalMileage: 0,\n            NewMileage: 0,\n            RouteDifference: 0,\n            Service: service.Service,\n            implementationPeriod: [[`${service.Implementation}`, \"[0,0,0,0,0,0]\"]],\n            tripCount: [0, 0, 0, 0, 0, 0]\n          }]\n        };\n      }\n    });\n  });\n\n  // Loop through Contracts Data\n  BusData.body.contracts.forEach(contract => {\n    contract.values.forEach(value => {\n      const period = value.implementationPeriod;\n      // Tag Route Amendment or Change in Trip Count to each value in contracts\n      value.routeAmendment = value.NewMileage === value.TotalMileage + value.RouteDifference;\n      value.changeInTripCount = value.NewMileage === 0 && value.TotalMileage === value.RouteDifference;\n      if (period && period.length > 0) {\n        const firstDate = period[0][0].split(\"-\")[0];\n        const lastDate = period[period.length - 1][0].split(\"-\")[1];\n        const contractKey = `${value.Service}_${firstDate}_${lastDate}`;\n\n        // Determine if there's a pre-existing bus fleet entry for this key\n        const preExistingBusFleet = results[contract.contract] && results[contract.contract][contractKey] && results[contract.contract][contractKey].onlyBusFleet;\n\n        // Condition B\n        if (preExistingBusFleet) {\n          let fleetEntry = results[contract.contract][contractKey];\n          fleetEntry.isMatch = true;\n          fleetEntry.onlyBusFleet = false;\n          fleetEntry.onlyContract = false;\n\n          // Check for defaultBusFleetValues to be removed if isMatch=True (So that you dont get bus fleet value mixed with contract values)\n          const hasDefaultBusFleetValues = fleetEntry.values.length === 1 && fleetEntry.values[0].TotalMileage === 0 && fleetEntry.values[0].NewMileage === 0 && fleetEntry.values[0].RouteDifference === 0;\n          if (hasDefaultBusFleetValues) {\n            fleetEntry.values = []; // Clear default values\n          }\n          fleetEntry.values.push(value); // Add contract data\n\n          // Condition C\n        } else {\n          results[contract.contract] = results[contract.contract] || {};\n          results[contract.contract][contractKey] = results[contract.contract][contractKey] || {\n            onlyBusFleet: false,\n            isMatch: false,\n            onlyContract: true,\n            BusFleet: [],\n            values: []\n          };\n          results[contract.contract][contractKey].values.push(value); // Add the contract value\n        }\n      }\n    });\n  });\n  return results;\n}\nconst checkedValues = checkBusFleet(BusData);\nconsole.log(\"muh checked values: \", checkedValues);\n\n// This Function sorts the services according to: Route Amendment (RA), Grouped Route Amendment (GRA), Change In Trip Count (CITC), Grouped Change In Trip Count (GCITC), Route Amendment & Change In Trip Count (RACITC), Not Applicable for onlyBusFleet=true (NA)\nfunction createCategorizedKeys(checkedValues) {\n  const keys = Object.keys(checkedValues);\n  keys.forEach(ptKey => {\n    const ptData = checkedValues[ptKey];\n    const ptDataKeys = Object.keys(ptData);\n    ptDataKeys.forEach(key => {\n      let routeAmendmentCount = 0;\n      let changeInTripCountCount = 0;\n      let isOnlyBusFleet = ptData[key].onlyBusFleet;\n\n      // If onlyBusFleet is true, then categorize as NA.\n      if (isOnlyBusFleet) {\n        checkedValues[ptKey][`${key}_NA`] = checkedValues[ptKey][key];\n        delete checkedValues[ptKey][key]; // Remove the original key\n        return;\n      }\n      ptData[key].values.forEach(value => {\n        if (value.routeAmendment) routeAmendmentCount++;\n        if (value.changeInTripCount) changeInTripCountCount++;\n      });\n      let suffix = \"\";\n      if (routeAmendmentCount === 1 && changeInTripCountCount === 0) {\n        // RA Condition\n        suffix = \"RA\";\n      } else if (routeAmendmentCount > 1 && changeInTripCountCount === 0) {\n        // GRA Condition\n        suffix = \"GRA\";\n      } else if (routeAmendmentCount === 0 && changeInTripCountCount === 1) {\n        // CITC Condition\n        suffix = \"CITC\";\n      } else if (routeAmendmentCount === 0 && changeInTripCountCount > 1) {\n        // GCITC Condition\n        suffix = \"GCITC\";\n      } else if (changeInTripCountCount >= 1 && routeAmendmentCount >= 1) {\n        // RACITC Conidition\n        suffix = \"RACITC\";\n      } else {\n        suffix = \"ERROR\"; // A fallback key suffix. (Check DATA!; TotalMileage/NewMileage/RouteDiff might not Tally.)\n      }\n\n      // Rename the key with the appropriate suffix\n      checkedValues[ptKey][`${key}_${suffix}`] = checkedValues[ptKey][key];\n      delete checkedValues[ptKey][key]; // Remove the original key\n    });\n  });\n  return checkedValues;\n}\nconst categorizedKeys = createCategorizedKeys(checkedValues);\nconsole.log(\"muh categorizedKeys:\", categorizedKeys);\n\n// This Function sorts the services according to: Route Amendment (RA), Grouped Route Amendment (GRA), Change In Trip Count (CITC), Grouped Change In Trip Count (GCITC), Route Amendment & Change In Trip Count (RACITC)\n// (Legacy function; to be deleted soon; replaced with createCategorizedKeys)\nfunction createSortedKeys(BusData) {\n  const results = {};\n  BusData.body.contracts.forEach(contract => {\n    const contractNumber = contract.contract;\n    const serviceInfo = {};\n    contract.values.forEach(value => {\n      // Check if values is RA or CITC. Label RA & CITC = true or false right into values.\n      value.routeAmendment = value.NewMileage === value.TotalMileage + value.RouteDifference;\n      value.changeInTripCount = value.NewMileage === 0 && value.TotalMileage === value.RouteDifference;\n\n      // Form DateKey for 1st stage seperation of firstDate & lastDate\n      const period = value.implementationPeriod;\n      const firstDate = period[0][0].split(\"-\")[0];\n      const lastDate = period[period.length - 1][0].split(\"-\")[1];\n      const serviceKey = `${value.Service}_${firstDate}_${lastDate}`;\n      serviceInfo[serviceKey] = serviceInfo[serviceKey] || {\n        RA: [],\n        CITC: [],\n        values: []\n      };\n      console.log(\" check this\", serviceInfo);\n      serviceInfo[serviceKey].values.push(value);\n\n      // Assign values to RA or CITC categories\n      if (value.routeAmendment) {\n        serviceInfo[serviceKey].RA.push(value);\n      }\n      if (value.changeInTripCount) {\n        serviceInfo[serviceKey].CITC.push(value);\n      }\n    });\n\n    // Process RACITC, RA/GRA, CITC/GCITC\n    Object.keys(serviceInfo).forEach(key => {\n      const group = serviceInfo[key];\n\n      // Identify RACITC groups\n      const racitcGroups = {};\n      group.values.forEach(value => {\n        const racitcKey = `${value.Direction}_${value.Pattern}`; // Implemented this in cases of: same service & same dates but different direction/patterns but all are RACICT.\n        if (group.RA.some(ra => ra.Direction === value.Direction && ra.Pattern === value.Pattern) && group.CITC.some(citc => citc.Direction === value.Direction && citc.Pattern === value.Pattern)) {\n          racitcGroups[racitcKey] = racitcGroups[racitcKey] || [];\n          racitcGroups[racitcKey].push(value);\n        }\n      });\n\n      // Create separate keys for RACITC groups\n      Object.keys(racitcGroups).forEach(racitcKey => {\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${racitcKey}_RACITC`] = {\n          values: racitcGroups[racitcKey]\n        };\n      });\n\n      // Categorize remaining values as RA/GRA and CITC/GCITC\n      const remainingRA = group.RA.filter(v => !racitcGroups[`${v.Direction}_${v.Pattern}`]);\n      const remainingCITC = group.CITC.filter(v => !racitcGroups[`${v.Direction}_${v.Pattern}`]);\n      if (remainingRA.length > 0) {\n        const typeKey = remainingRA.length > 1 ? \"GRA\" : \"RA\";\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${typeKey}`] = {\n          values: remainingRA\n        };\n      }\n      if (remainingCITC.length > 0) {\n        const typeKey = remainingCITC.length > 1 ? \"GCITC\" : \"CITC\";\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${typeKey}`] = {\n          values: remainingCITC\n        };\n      }\n    });\n  });\n  return results;\n}\nconst sortedKeys = createSortedKeys(BusData);\n//console.log(\"muh sortedKeys:\", sortedKeys);\n\nfunction calculateAdditionalMileage(categorizedKeys) {\n  const results = {};\n  function calculateRA(values) {\n    const RouteDifference = parseFloat(values[0].RouteDifference);\n    const tripCount = values[0].tripCount;\n    return tripCount.map(count => parseFloat((RouteDifference * count).toFixed(2)));\n  }\n  function calculateGRA(values) {\n    let results = [];\n    values.forEach(value => {\n      const RouteDifference = parseFloat(value.RouteDifference);\n      const tripCounts = value.tripCount.map(count => parseFloat(count));\n      let result = tripCounts.map(count => RouteDifference * count);\n      results.push(result);\n    });\n    return results.reduce((accumulator, currentArray) => accumulator.map((sum, index) => sum + (currentArray[index] || 0)));\n  }\n  function calculateCITC(values) {\n    const TotalMileage = parseFloat(values[0].TotalMileage);\n    const tripCount = values[0].tripCount;\n    return tripCount.map(count => parseFloat((TotalMileage * count).toFixed(2)));\n  }\n  function calculateGCITC(values) {\n    let results = [];\n    values.forEach(value => {\n      const TotalMileage = parseFloat(value.TotalMileage);\n      const tripCounts = value.tripCount.map(count => parseFloat(count));\n      let result = tripCounts.map(count => TotalMileage * count);\n      results.push(result);\n    });\n    return results.reduce((accumulator, currentArray) => accumulator.map((sum, index) => sum + (currentArray[index] || 0)));\n  }\n  function calculateRACITC(values) {\n    // Find the entry with routeAmendment to extract its RouteDifference\n    const routeAmendmentEntry = values.find(value => value.routeAmendment === true);\n    const routeAmendmentValue = routeAmendmentEntry ? parseFloat(routeAmendmentEntry.RouteDifference) : 0;\n    let results = [];\n    values.forEach(value => {\n      const tripCounts = value.tripCount.map(count => parseFloat(count));\n      let result;\n      if (value.routeAmendment === true) {\n        // For RA: Use the RouteAmendment value directly with the tripCount from the same entry\n        result = tripCounts.map(count => routeAmendmentValue * count);\n      } else if (value.changeInTripCount === true) {\n        // For CITC: Use TotalMileage + RouteAmendment from the routeAmendment entry and multiply by the tripCount\n        const TotalMileagePlusAmendment = parseFloat(value.TotalMileage) + routeAmendmentValue;\n        result = tripCounts.map(count => TotalMileagePlusAmendment * count);\n      }\n      if (result) {\n        results.push(result);\n      }\n    });\n    return results.reduce((accumulator, currentArray) => accumulator.map((sum, index) => sum + (currentArray[index] || 0)), Array(routeAmendmentEntry.tripCount.length).fill(0));\n  }\n  function calculateNA(values) {\n    if (values && values.length > 0) {\n      const tripCount = values[0].tripCount;\n      return tripCount;\n    }\n  }\n  Object.entries(categorizedKeys).forEach(([key, keys]) => {\n    results[key] = {};\n    Object.keys(keys).forEach(typeKey => {\n      const typeParts = typeKey.split(\"_\");\n      const type = typeParts[typeParts.length - 1];\n      const values = keys[typeKey].values;\n      switch (type) {\n        case \"RA\":\n          results[key][typeKey] = calculateRA(values);\n          break;\n        case \"GRA\":\n          results[key][typeKey] = calculateGRA(values);\n          break;\n        case \"CITC\":\n          results[key][typeKey] = calculateCITC(values);\n          break;\n        case \"GCITC\":\n          results[key][typeKey] = calculateGCITC(values);\n          break;\n        case \"RACITC\":\n          results[key][typeKey] = calculateRACITC(values);\n          break;\n        case \"NA\":\n          results[key][typeKey] = calculateNA(values);\n          break;\n      }\n    });\n  });\n  return results;\n}\nconst additionalMileage = calculateAdditionalMileage(categorizedKeys);\nconsole.log(\"muh additionalMileage\", additionalMileage);\n\n// This extracts the e.g [153,39,39,51,0,0]\nfunction extractFrequencyByDayType(categorizedKeys) {\n  const results = {};\n\n  // Iterate over each contract in sortedKeys\n  Object.keys(categorizedKeys).forEach(contractKey => {\n    const services = categorizedKeys[contractKey];\n    results[contractKey] = {};\n\n    // Iterate over each service in the contract\n    Object.keys(services).forEach(serviceKey => {\n      // Directly access the 'values' array from the provided structure\n      const serviceValues = services[serviceKey].values;\n\n      // Check if 'values' exists and has elements\n      if (serviceValues && serviceValues.length > 0) {\n        // Assuming we want to capture the entire 'implementationPeriod' data for the service\n        const implementationPeriodData = serviceValues[0].implementationPeriod.map(period => {\n          return period[1];\n        });\n\n        // Store the collected implementation period data under the original service key\n        results[contractKey][serviceKey] = implementationPeriodData;\n      }\n    });\n  });\n  return results;\n}\nconst frequencyByDayType = extractFrequencyByDayType(categorizedKeys);\nconsole.log(\"muh frequencyByDayType\", frequencyByDayType);\n\n// For calculating Dates, noOfBus, unitCosts, grandTotal\nfunction calculateLeaseFeeDetails(categorizedKeys) {\n  const results = {};\n  Object.entries(categorizedKeys).forEach(([categoryKey, services]) => {\n    results[categoryKey] = {};\n    Object.entries(services).forEach(([serviceKey, serviceDetails]) => {\n      const transactionDetails = [];\n      let grandTotal = new bigDecimal(0);\n\n      // Process only if isMatch is true or onlyBusFleet is true\n      if (serviceDetails.isMatch === true || serviceDetails.onlyBusFleet === true) {\n        const transactions = serviceDetails.BusFleet ? serviceDetails.BusFleet.Transaction : serviceDetails.Transaction;\n        for (const key in transactions) {\n          const transaction = transactions[key];\n          // Calculate unit and total costs\n          let unitCost = new bigDecimal(transaction[2]);\n          let totalUnitCost = new bigDecimal(transaction[1]).multiply(unitCost);\n          grandTotal = grandTotal.add(totalUnitCost);\n          transactionDetails.push({\n            Transaction: key,\n            \"Handover/Return Date\": formatDateForTransactions(transaction[0]),\n            \"No. of Buses\": transaction[1],\n            \"Unit Cost\": unitCost.getValue(),\n            \"Total Unit Cost\": totalUnitCost.getValue()\n          });\n        }\n\n        // Store the computed details in the results\n        results[categoryKey][serviceKey] = {\n          grandTotal: grandTotal.getValue(),\n          transactions: transactionDetails\n        };\n      }\n    });\n  });\n  return results;\n}\nconst leaseFeeDetails = calculateLeaseFeeDetails(categorizedKeys);\nconsole.log(\"muh report #1 leaseFee\", leaseFeeDetails);\nfunction calculateFirstReportData(categorizedKeys, additionalMileage, frequencyByDayType, leaseFeeDetails) {\n  let results = {};\n  const inflationRate = new bigDecimal(1.02); // 2% Inflation Rate\n  const baseUnitRate = new bigDecimal(BusData.body.unitRate); // Base Unit Rate\n  const fuelRate = new bigDecimal(BusData.body.fuelRate); // Fuel Rate\n\n  Object.keys(categorizedKeys).forEach(contractNumber => {\n    results[contractNumber] = {};\n    Object.keys(categorizedKeys[contractNumber]).forEach(uniqueKey => {\n      results[contractNumber][uniqueKey] = [];\n      let periods = categorizedKeys[contractNumber][uniqueKey].values[0].implementationPeriod;\n      let currentUnitRate = baseUnitRate;\n      periods.forEach((periodPair, index) => {\n        currentUnitRate = index > 0 ? currentUnitRate.multiply(inflationRate).round(2, bigDecimal.RoundingModes.HALF_UP) : currentUnitRate;\n        const [periodDateStart, periodDateEnd] = periodPair[0].split(\"-\");\n        const periodEndYear = periodPair[0].slice(-4);\n        const dayJSPeriodDateStart = formatDateDayJS(periodDateStart);\n        const dayJSPeriodDateEnd = formatDateDayJS(periodDateEnd);\n        const dayJSPeriodDateEndForDateDiff = dayjs(dayJSPeriodDateEnd).add(1, \"day\").format(\"YYYY-MM-DD\");\n        const periodDateDiff = new bigDecimal(dayjs(dayJSPeriodDateEndForDateDiff).diff(dayjs(dayJSPeriodDateStart), \"month\", true)).round(2, bigDecimal.RoundingModes.HALF_UP);\n\n        // For First Period Lease Fee Calculation\n        // First Period Lease Fee  Logic: Compare Handover/ReturnDate with 1st Period's \"Duration TO\" then multiply totalUnitCost E.g: DiesalSD: [190224, 3, 100] -> (3 * 100 = 300).\n        let firstPeriodLeaseFeeCalculation = new bigDecimal(0);\n        if (index === 0 && leaseFeeDetails[contractNumber] && leaseFeeDetails[contractNumber][uniqueKey]) {\n          console.log(`- Calculating for contract: ${contractNumber}, service: ${uniqueKey}`);\n          leaseFeeDetails[contractNumber][uniqueKey].transactions.forEach((transaction, transactionIndex) => {\n            const transactionDate = formatLeaseFeeDetailsDateDayJS(transaction[\"Handover/Return Date\"]);\n            const dateDiff = new bigDecimal(dayjs(dayJSPeriodDateEndForDateDiff).diff(dayjs(transactionDate), \"month\", true)).round(2, bigDecimal.RoundingModes.HALF_UP);\n            const totalUnitCost = new bigDecimal(transaction[\"Total Unit Cost\"]);\n            const transactionLeaseFee = totalUnitCost.multiply(dateDiff).round(2, bigDecimal.RoundingModes.HALF_UP);\n            firstPeriodLeaseFeeCalculation = firstPeriodLeaseFeeCalculation.add(transactionLeaseFee);\n\n            // How to check firstPeriodLeaseFeeCalculation 101 (dont modify or remove this):\n            // 1. Use \"-\" in console search bar\n            // 2. Check difference of(transactionDate & dayJSPeriodDateEndForDateDiff) == dateDiff\n            // 3. Check if totalUnitCost is correct in Transaction. E.g: DiesalSD: [190224, 3, 100] -> (3 * 100 = 300).\n            // 4. Check if transactionLeaseFee = diffDiff * totalUnitCost\n            // 5. Check firstPeriodLeaseFeeCalculation has added all transactionLeaseFee*S* (with a S because there can be multiple Transactions)\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction #${transactionIndex + 1} (${transaction[\"Transaction\"]}) Details:`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction Date: ${transactionDate}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Lease Fee Date End (+1 day offset): ${dayJSPeriodDateEndForDateDiff}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Date Difference (Months): ${dateDiff.getValue()}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Total Unit Cost: ${totalUnitCost.getValue()}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction Lease Fee: ${transactionLeaseFee.getValue()}`);\n          });\n          // prettier-ignore\n          console.log(`[${contractNumber}][${uniqueKey}] - First Period Lease Fee Calculation Total: ${firstPeriodLeaseFeeCalculation.getValue()}`);\n        }\n        let periodMileage = new bigDecimal(0);\n        if (frequencyByDayType[contractNumber] && frequencyByDayType[contractNumber][uniqueKey] && additionalMileage[contractNumber] && additionalMileage[contractNumber][uniqueKey]) {\n          let freqArray = JSON.parse(frequencyByDayType[contractNumber][uniqueKey][index]);\n          let additional = additionalMileage[contractNumber][uniqueKey];\n          periodMileage = freqArray.reduce((sum, freq, idx) => sum.add(new bigDecimal(freq).multiply(new bigDecimal(additional[idx]))), new bigDecimal(0));\n        }\n        const YearlySF = periodMileage.multiply(currentUnitRate).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const fuelCost = periodMileage.multiply(fuelRate).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const periodUnitRFuelR = currentUnitRate.add(fuelRate);\n        const periodSfCost = YearlySF.add(fuelCost);\n        const grandTotal = leaseFeeDetails[contractNumber] && leaseFeeDetails[contractNumber][uniqueKey] ? new bigDecimal(leaseFeeDetails[contractNumber][uniqueKey].grandTotal) : new bigDecimal(0);\n        const periodLeaseFee = index === 0 ? firstPeriodLeaseFeeCalculation : periodDateDiff.multiply(grandTotal).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const periodTotalCost = periodLeaseFee.add(periodSfCost);\n        results[contractNumber][uniqueKey].push({\n          endYear: periodEndYear,\n          dayJSPeriodDateStart: dayJSPeriodDateStart,\n          dayJSPeriodDateEnd: dayJSPeriodDateEnd,\n          dateStart: formatDateForDuration(dayJSPeriodDateStart),\n          dateEnd: formatDateForDuration(dayJSPeriodDateEnd),\n          mileage: periodMileage.getValue(),\n          unitRate: currentUnitRate.getValue(),\n          YearlySF: YearlySF.getValue(),\n          fuelRate: fuelRate.getValue(),\n          fuelCost: fuelCost.getValue(),\n          UnitRFuelR: periodUnitRFuelR.getValue(),\n          sfCost: periodSfCost.getValue(),\n          dateDiff: periodDateDiff.getValue(),\n          leaseFee: periodLeaseFee.getValue(),\n          totalCost: periodTotalCost.getValue(),\n          unitCostTotal: grandTotal.getValue()\n        });\n      });\n    });\n  });\n  return results;\n}\nconst FirstReportData = calculateFirstReportData(categorizedKeys, additionalMileage, frequencyByDayType, leaseFeeDetails);\nconsole.log(\"muh report #1 data\", FirstReportData);\nfunction calculateTotalData() {\n  const result = {};\n\n  // Calculate Frequency By Day Type Totals\n  for (const contract in frequencyByDayType) {\n    result[contract] = result[contract] || {};\n    for (const service in frequencyByDayType[contract]) {\n      const dataArrays = frequencyByDayType[contract][service].map(str => JSON.parse(str));\n      result[contract][service] = {\n        MonToThurs: dataArrays.reduce((sum, arr) => sum + arr[0], 0),\n        Friday: dataArrays.reduce((sum, arr) => sum + arr[1], 0),\n        Saturdays: dataArrays.reduce((sum, arr) => sum + arr[2], 0),\n        Sundays: dataArrays.reduce((sum, arr) => sum + arr[3], 0),\n        SchHoliday: dataArrays.reduce((sum, arr) => sum + arr[4], 0),\n        Others: dataArrays.reduce((sum, arr) => sum + arr[5], 0)\n      };\n    }\n  }\n  // Loop through each contract in FirstReportData\n  for (const contract in FirstReportData) {\n    result[contract] = result[contract] || {};\n\n    // Loop through each service in the contract\n    for (const service in FirstReportData[contract]) {\n      var _FirstReportData$cont, _FirstReportData$cont2, _FirstReportData$cont3, _FirstReportData$cont4;\n      let year = new bigDecimal(365);\n      let totalMileage = new bigDecimal(0);\n      let totalYearlySF = new bigDecimal(0);\n      let totalFuelCost = new bigDecimal(0);\n      let totalSfCost = new bigDecimal(0);\n      let totalCost = new bigDecimal(0);\n      let annualMileage = new bigDecimal(0);\n      let annualSF = new bigDecimal(0);\n      let annualLF = new bigDecimal(0);\n      let annualCost = new bigDecimal(0);\n      let annualCostCrr = new bigDecimal(0);\n      const tripCountSum = Object.values(result[contract][service] || {}).reduce((sum, count) => sum + count, 0);\n      const firstUnitRateFuelRate = parseFloat(((_FirstReportData$cont = FirstReportData[contract][service].find(data => data.UnitRFuelR)) === null || _FirstReportData$cont === void 0 ? void 0 : _FirstReportData$cont.UnitRFuelR) || 0);\n      const monthlyLF = parseFloat(((_FirstReportData$cont2 = FirstReportData[contract][service].find(data => data.unitCostTotal)) === null || _FirstReportData$cont2 === void 0 ? void 0 : _FirstReportData$cont2.unitCostTotal) || 0);\n      const voStartDate = ((_FirstReportData$cont3 = FirstReportData[contract][service][0]) === null || _FirstReportData$cont3 === void 0 ? void 0 : _FirstReportData$cont3.dayJSPeriodDateStart) || \"error-retriving-date\";\n      const voEndDate = ((_FirstReportData$cont4 = FirstReportData[contract][service][FirstReportData[contract][service].length - 1]) === null || _FirstReportData$cont4 === void 0 ? void 0 : _FirstReportData$cont4.dayJSPeriodDateEnd) || \"error-retriving-date\";\n      FirstReportData[contract][service].forEach(period => {\n        totalMileage = totalMileage.add(new bigDecimal(period.mileage || 0));\n        totalYearlySF = totalYearlySF.add(new bigDecimal(period.YearlySF || 0));\n        totalFuelCost = totalFuelCost.add(new bigDecimal(period.fuelCost || 0));\n        totalSfCost = totalSfCost.add(new bigDecimal(period.sfCost || 0));\n        totalCost = totalCost.add(new bigDecimal(period.totalCost || 0));\n      });\n\n      // Check if tripCountSum is 0 to avoid division by zero error; tripCountSum is 0 when NA conditions (onlyBusFleet=True).\n      if (tripCountSum === 0) {\n        annualMileage = new bigDecimal(0);\n      } else {\n        // Proceed with the division if tripCountSum is not 0\n        annualMileage = totalMileage.divide(new bigDecimal(tripCountSum)).multiply(year);\n      }\n      let numericTotalCost = parseFloat(totalCost.getValue());\n      annualSF = annualMileage.multiply(new bigDecimal(firstUnitRateFuelRate)).round(2, bigDecimal.RoundingModes.HALF_UP).getValue();\n      annualLF = new bigDecimal(monthlyLF).multiply(new bigDecimal(12)).round(2, bigDecimal.RoundingModes.HALF_UP).getValue();\n      annualCost = new bigDecimal(annualSF).add(new bigDecimal(annualLF)).round(2, bigDecimal.RoundingModes.HALF_UP).getValue();\n      result[contract][service] = {\n        ...result[contract][service],\n        totalMileage: totalMileage.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        totalYearlySF: totalYearlySF.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        totalFuelCost: totalFuelCost.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        totalSfCost: totalSfCost.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        totalCost: totalCost.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        totalAmountReq: roundGrandTotal1000(numericTotalCost).toString(),\n        annualMileage: annualMileage.round(2, bigDecimal.RoundingModes.HALF_UP).getValue(),\n        annualSF: annualSF,\n        annualLF: annualLF,\n        annualCost: annualCost,\n        voStartDate: formatDateForVO(voStartDate),\n        voEndDate: formatDateForVO(voEndDate),\n        annualCostCrr: annualCostCrr.round(2, bigDecimal.RoundingModes.HALF_UP).getValue()\n      };\n    }\n  }\n  return result;\n}\nconst totalFirstReportData = calculateTotalData();\nconsole.log(\"muh report #1 total data\", totalFirstReportData);\nexport { findServiceData, checkedValues, categorizedKeys, sortedKeys, additionalMileage, frequencyByDayType, leaseFeeDetails, FirstReportData, totalFirstReportData };","map":{"version":3,"names":["dayjs","bigDecimal","formatDateDayJS","formatLeaseFeeDetailsDateDayJS","formatDateForDuration","formatDateForTransactions","formatDateForVO","BusData","roundGrandTotal1000","findServiceData","dataSet","selectedService","isLeaseFee","contract","checkBusFleet","results","body","busFleet","forEach","fleet","values","service","startDate","endDate","Implementation","split","busFleetKey","Service","onlyBusFleet","isMatch","onlyContract","BusFleet","Transaction","TotalMileage","NewMileage","RouteDifference","implementationPeriod","tripCount","contracts","value","period","routeAmendment","changeInTripCount","length","firstDate","lastDate","contractKey","preExistingBusFleet","fleetEntry","hasDefaultBusFleetValues","push","checkedValues","console","log","createCategorizedKeys","keys","Object","ptKey","ptData","ptDataKeys","key","routeAmendmentCount","changeInTripCountCount","isOnlyBusFleet","suffix","categorizedKeys","createSortedKeys","contractNumber","serviceInfo","serviceKey","RA","CITC","group","racitcGroups","racitcKey","Direction","Pattern","some","ra","citc","remainingRA","filter","v","remainingCITC","typeKey","sortedKeys","calculateAdditionalMileage","calculateRA","parseFloat","map","count","toFixed","calculateGRA","tripCounts","result","reduce","accumulator","currentArray","sum","index","calculateCITC","calculateGCITC","calculateRACITC","routeAmendmentEntry","find","routeAmendmentValue","TotalMileagePlusAmendment","Array","fill","calculateNA","entries","typeParts","type","additionalMileage","extractFrequencyByDayType","services","serviceValues","implementationPeriodData","frequencyByDayType","calculateLeaseFeeDetails","categoryKey","serviceDetails","transactionDetails","grandTotal","transactions","transaction","unitCost","totalUnitCost","multiply","add","getValue","leaseFeeDetails","calculateFirstReportData","inflationRate","baseUnitRate","unitRate","fuelRate","uniqueKey","periods","currentUnitRate","periodPair","round","RoundingModes","HALF_UP","periodDateStart","periodDateEnd","periodEndYear","slice","dayJSPeriodDateStart","dayJSPeriodDateEnd","dayJSPeriodDateEndForDateDiff","format","periodDateDiff","diff","firstPeriodLeaseFeeCalculation","transactionIndex","transactionDate","dateDiff","transactionLeaseFee","periodMileage","freqArray","JSON","parse","additional","freq","idx","YearlySF","fuelCost","periodUnitRFuelR","periodSfCost","periodLeaseFee","periodTotalCost","endYear","dateStart","dateEnd","mileage","UnitRFuelR","sfCost","leaseFee","totalCost","unitCostTotal","FirstReportData","calculateTotalData","dataArrays","str","MonToThurs","arr","Friday","Saturdays","Sundays","SchHoliday","Others","_FirstReportData$cont","_FirstReportData$cont2","_FirstReportData$cont3","_FirstReportData$cont4","year","totalMileage","totalYearlySF","totalFuelCost","totalSfCost","annualMileage","annualSF","annualLF","annualCost","annualCostCrr","tripCountSum","firstUnitRateFuelRate","data","monthlyLF","voStartDate","voEndDate","divide","numericTotalCost","totalAmountReq","toString","totalFirstReportData"],"sources":["/Users/caizhitan/BCM_Reports/src/Pages/Admin/Reports/FirstReport/FirstReportData.js"],"sourcesContent":["import dayjs from \"dayjs\";\nimport bigDecimal from \"js-big-decimal\"; // Excel uses HALF-UP Rounding\nimport {\n  formatDateDayJS,\n  formatLeaseFeeDetailsDateDayJS,\n  formatDateForDuration,\n  formatDateForTransactions,\n  formatDateForVO,\n} from \"../../FormatDate\";\nimport { BusData } from \"../../DummyData\"\nimport { roundGrandTotal1000 } from \"../../RoundingRules\";\n//test\n// Function to extract data specifically for User Selected Service\nfunction findServiceData(dataSet, selectedService, isLeaseFee = false) {\n  if (isLeaseFee) {\n    for (const contract in dataSet) {\n      if (dataSet[contract][selectedService]) {\n        return dataSet[contract][selectedService] || null;\n      }\n    }\n  } else {\n    // For all other Data values\n    for (const contract in dataSet) {\n      if (dataSet[contract][selectedService]) {\n        return dataSet[contract][selectedService];\n      }\n    }\n    return null;\n  }\n}\n\n// This Function handles 3 conditions. A: Only Bus Fleet Values | B: Bus Fleet and Contract Values Match | C: Only Contract Values\n// Condition B happens when Bus Fleet & Contract Implementation Start and End date are the same.\nfunction checkBusFleet(BusData) {\n  const results = {};\n\n  // Loop through Bus Fleet Data first\n  BusData.body.busFleet.forEach((fleet) => {\n    if (!results[fleet.contract]) {\n      results[fleet.contract] = {};\n    }\n\n    fleet.values.forEach((service) => {\n      const [startDate, endDate] = service.Implementation[0].split(\"-\");\n      const busFleetKey = `${service.Service}_${startDate}_${endDate}`;\n\n      // Initialize bus fleet entry if it doesn't exist\n      if (!results[fleet.contract][busFleetKey]) {\n        results[fleet.contract][busFleetKey] = {\n          onlyBusFleet: true,\n          isMatch: false,\n          onlyContract: false,\n          BusFleet: {\n            Transaction: service.Transaction,\n            Implementation: service.Implementation,\n          },\n          // Default values for onlyBusFleet\n          values: [\n            {\n              TotalMileage: 0,\n              NewMileage: 0,\n              RouteDifference: 0,\n              Service: service.Service,\n              implementationPeriod: [\n                [`${service.Implementation}`, \"[0,0,0,0,0,0]\"],\n              ],\n              tripCount: [0, 0, 0, 0, 0, 0],\n            },\n          ],\n        };\n      }\n    });\n  });\n\n  // Loop through Contracts Data\n  BusData.body.contracts.forEach((contract) => {\n    contract.values.forEach((value) => {\n      const period = value.implementationPeriod;\n      // Tag Route Amendment or Change in Trip Count to each value in contracts\n      value.routeAmendment =\n        value.NewMileage === value.TotalMileage + value.RouteDifference;\n      value.changeInTripCount =\n        value.NewMileage === 0 && value.TotalMileage === value.RouteDifference;\n\n      if (period && period.length > 0) {\n        const firstDate = period[0][0].split(\"-\")[0];\n        const lastDate = period[period.length - 1][0].split(\"-\")[1];\n        const contractKey = `${value.Service}_${firstDate}_${lastDate}`;\n\n        // Determine if there's a pre-existing bus fleet entry for this key\n        const preExistingBusFleet =\n          results[contract.contract] &&\n          results[contract.contract][contractKey] &&\n          results[contract.contract][contractKey].onlyBusFleet;\n\n        // Condition B\n        if (preExistingBusFleet) {\n          let fleetEntry = results[contract.contract][contractKey];\n          fleetEntry.isMatch = true;\n          fleetEntry.onlyBusFleet = false;\n          fleetEntry.onlyContract = false;\n\n          // Check for defaultBusFleetValues to be removed if isMatch=True (So that you dont get bus fleet value mixed with contract values)\n          const hasDefaultBusFleetValues =\n            fleetEntry.values.length === 1 &&\n            fleetEntry.values[0].TotalMileage === 0 &&\n            fleetEntry.values[0].NewMileage === 0 &&\n            fleetEntry.values[0].RouteDifference === 0;\n          if (hasDefaultBusFleetValues) {\n            fleetEntry.values = []; // Clear default values\n          }\n          fleetEntry.values.push(value); // Add contract data\n\n          // Condition C\n        } else {\n          results[contract.contract] = results[contract.contract] || {};\n          results[contract.contract][contractKey] = results[contract.contract][\n            contractKey\n          ] || {\n            onlyBusFleet: false,\n            isMatch: false,\n            onlyContract: true,\n            BusFleet: [],\n            values: [],\n          };\n          results[contract.contract][contractKey].values.push(value); // Add the contract value\n        }\n      }\n    });\n  });\n\n  return results;\n}\n\nconst checkedValues = checkBusFleet(BusData);\nconsole.log(\"muh checked values: \", checkedValues);\n\n// This Function sorts the services according to: Route Amendment (RA), Grouped Route Amendment (GRA), Change In Trip Count (CITC), Grouped Change In Trip Count (GCITC), Route Amendment & Change In Trip Count (RACITC), Not Applicable for onlyBusFleet=true (NA)\nfunction createCategorizedKeys(checkedValues) {\n  const keys = Object.keys(checkedValues);\n\n  keys.forEach((ptKey) => {\n    const ptData = checkedValues[ptKey];\n    const ptDataKeys = Object.keys(ptData);\n\n    ptDataKeys.forEach((key) => {\n      let routeAmendmentCount = 0;\n      let changeInTripCountCount = 0;\n      let isOnlyBusFleet = ptData[key].onlyBusFleet;\n\n      // If onlyBusFleet is true, then categorize as NA.\n      if (isOnlyBusFleet) {\n        checkedValues[ptKey][`${key}_NA`] = checkedValues[ptKey][key];\n        delete checkedValues[ptKey][key]; // Remove the original key\n        return;\n      }\n\n      ptData[key].values.forEach((value) => {\n        if (value.routeAmendment) routeAmendmentCount++;\n        if (value.changeInTripCount) changeInTripCountCount++;\n      });\n\n      let suffix = \"\";\n      if (routeAmendmentCount === 1 && changeInTripCountCount === 0) {\n        // RA Condition\n        suffix = \"RA\";\n      } else if (routeAmendmentCount > 1 && changeInTripCountCount === 0) {\n        // GRA Condition\n        suffix = \"GRA\";\n      } else if (routeAmendmentCount === 0 && changeInTripCountCount === 1) {\n        // CITC Condition\n        suffix = \"CITC\";\n      } else if (routeAmendmentCount === 0 && changeInTripCountCount > 1) {\n        // GCITC Condition\n        suffix = \"GCITC\";\n      } else if (changeInTripCountCount >= 1 && routeAmendmentCount >= 1) {\n        // RACITC Conidition\n        suffix = \"RACITC\";\n      } else {\n        suffix = \"ERROR\"; // A fallback key suffix. (Check DATA!; TotalMileage/NewMileage/RouteDiff might not Tally.)\n      }\n\n      // Rename the key with the appropriate suffix\n      checkedValues[ptKey][`${key}_${suffix}`] = checkedValues[ptKey][key];\n      delete checkedValues[ptKey][key]; // Remove the original key\n    });\n  });\n\n  return checkedValues;\n}\n\nconst categorizedKeys = createCategorizedKeys(checkedValues);\nconsole.log(\"muh categorizedKeys:\", categorizedKeys);\n\n// This Function sorts the services according to: Route Amendment (RA), Grouped Route Amendment (GRA), Change In Trip Count (CITC), Grouped Change In Trip Count (GCITC), Route Amendment & Change In Trip Count (RACITC)\n// (Legacy function; to be deleted soon; replaced with createCategorizedKeys)\nfunction createSortedKeys(BusData) {\n  const results = {};\n\n  BusData.body.contracts.forEach((contract) => {\n    const contractNumber = contract.contract;\n    const serviceInfo = {};\n    contract.values.forEach((value) => {\n      // Check if values is RA or CITC. Label RA & CITC = true or false right into values.\n      value.routeAmendment =\n        value.NewMileage === value.TotalMileage + value.RouteDifference;\n      value.changeInTripCount =\n        value.NewMileage === 0 && value.TotalMileage === value.RouteDifference;\n\n      // Form DateKey for 1st stage seperation of firstDate & lastDate\n      const period = value.implementationPeriod;\n      const firstDate = period[0][0].split(\"-\")[0];\n      const lastDate = period[period.length - 1][0].split(\"-\")[1];\n      const serviceKey = `${value.Service}_${firstDate}_${lastDate}`;\n      serviceInfo[serviceKey] = serviceInfo[serviceKey] || {\n        RA: [],\n        CITC: [],\n        values: [],\n      };\n      console.log(\" check this\", serviceInfo);\n      serviceInfo[serviceKey].values.push(value);\n\n      // Assign values to RA or CITC categories\n      if (value.routeAmendment) {\n        serviceInfo[serviceKey].RA.push(value);\n      }\n      if (value.changeInTripCount) {\n        serviceInfo[serviceKey].CITC.push(value);\n      }\n    });\n\n    // Process RACITC, RA/GRA, CITC/GCITC\n    Object.keys(serviceInfo).forEach((key) => {\n      const group = serviceInfo[key];\n\n      // Identify RACITC groups\n      const racitcGroups = {};\n      group.values.forEach((value) => {\n        const racitcKey = `${value.Direction}_${value.Pattern}`; // Implemented this in cases of: same service & same dates but different direction/patterns but all are RACICT.\n        if (\n          group.RA.some(\n            (ra) =>\n              ra.Direction === value.Direction && ra.Pattern === value.Pattern\n          ) &&\n          group.CITC.some(\n            (citc) =>\n              citc.Direction === value.Direction &&\n              citc.Pattern === value.Pattern\n          )\n        ) {\n          racitcGroups[racitcKey] = racitcGroups[racitcKey] || [];\n          racitcGroups[racitcKey].push(value);\n        }\n      });\n\n      // Create separate keys for RACITC groups\n      Object.keys(racitcGroups).forEach((racitcKey) => {\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${racitcKey}_RACITC`] = {\n          values: racitcGroups[racitcKey],\n        };\n      });\n\n      // Categorize remaining values as RA/GRA and CITC/GCITC\n      const remainingRA = group.RA.filter(\n        (v) => !racitcGroups[`${v.Direction}_${v.Pattern}`]\n      );\n      const remainingCITC = group.CITC.filter(\n        (v) => !racitcGroups[`${v.Direction}_${v.Pattern}`]\n      );\n\n      if (remainingRA.length > 0) {\n        const typeKey = remainingRA.length > 1 ? \"GRA\" : \"RA\";\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${typeKey}`] = { values: remainingRA };\n      }\n\n      if (remainingCITC.length > 0) {\n        const typeKey = remainingCITC.length > 1 ? \"GCITC\" : \"CITC\";\n        results[contractNumber] = results[contractNumber] || {};\n        results[contractNumber][`${key}_${typeKey}`] = {\n          values: remainingCITC,\n        };\n      }\n    });\n  });\n\n  return results;\n}\n\nconst sortedKeys = createSortedKeys(BusData);\n//console.log(\"muh sortedKeys:\", sortedKeys);\n\nfunction calculateAdditionalMileage(categorizedKeys) {\n  const results = {};\n\n  function calculateRA(values) {\n    const RouteDifference = parseFloat(values[0].RouteDifference);\n    const tripCount = values[0].tripCount;\n\n    return tripCount.map((count) =>\n      parseFloat((RouteDifference * count).toFixed(2))\n    );\n  }\n\n  function calculateGRA(values) {\n    let results = [];\n\n    values.forEach((value) => {\n      const RouteDifference = parseFloat(value.RouteDifference);\n      const tripCounts = value.tripCount.map((count) => parseFloat(count));\n\n      let result = tripCounts.map((count) => RouteDifference * count);\n      results.push(result);\n    });\n\n    return results.reduce((accumulator, currentArray) =>\n      accumulator.map((sum, index) => sum + (currentArray[index] || 0))\n    );\n  }\n\n  function calculateCITC(values) {\n    const TotalMileage = parseFloat(values[0].TotalMileage);\n    const tripCount = values[0].tripCount;\n\n    return tripCount.map((count) =>\n      parseFloat((TotalMileage * count).toFixed(2))\n    );\n  }\n\n  function calculateGCITC(values) {\n    let results = [];\n\n    values.forEach((value) => {\n      const TotalMileage = parseFloat(value.TotalMileage);\n      const tripCounts = value.tripCount.map((count) => parseFloat(count));\n\n      let result = tripCounts.map((count) => TotalMileage * count);\n      results.push(result);\n    });\n\n    return results.reduce((accumulator, currentArray) =>\n      accumulator.map((sum, index) => sum + (currentArray[index] || 0))\n    );\n  }\n\n  function calculateRACITC(values) {\n    // Find the entry with routeAmendment to extract its RouteDifference\n    const routeAmendmentEntry = values.find(\n      (value) => value.routeAmendment === true\n    );\n    const routeAmendmentValue = routeAmendmentEntry\n      ? parseFloat(routeAmendmentEntry.RouteDifference)\n      : 0;\n\n    let results = [];\n\n    values.forEach((value) => {\n      const tripCounts = value.tripCount.map((count) => parseFloat(count));\n      let result;\n\n      if (value.routeAmendment === true) {\n        // For RA: Use the RouteAmendment value directly with the tripCount from the same entry\n        result = tripCounts.map((count) => routeAmendmentValue * count);\n      } else if (value.changeInTripCount === true) {\n        // For CITC: Use TotalMileage + RouteAmendment from the routeAmendment entry and multiply by the tripCount\n        const TotalMileagePlusAmendment =\n          parseFloat(value.TotalMileage) + routeAmendmentValue;\n        result = tripCounts.map((count) => TotalMileagePlusAmendment * count);\n      }\n\n      if (result) {\n        results.push(result);\n      }\n    });\n    return results.reduce(\n      (accumulator, currentArray) =>\n        accumulator.map((sum, index) => sum + (currentArray[index] || 0)),\n      Array(routeAmendmentEntry.tripCount.length).fill(0)\n    );\n  }\n\n  function calculateNA(values) {\n    if (values && values.length > 0) {\n      const tripCount = values[0].tripCount;\n\n      return tripCount;\n    }\n  }\n\n  Object.entries(categorizedKeys).forEach(([key, keys]) => {\n    results[key] = {};\n\n    Object.keys(keys).forEach((typeKey) => {\n      const typeParts = typeKey.split(\"_\");\n      const type = typeParts[typeParts.length - 1];\n      const values = keys[typeKey].values;\n\n      switch (type) {\n        case \"RA\":\n          results[key][typeKey] = calculateRA(values);\n          break;\n        case \"GRA\":\n          results[key][typeKey] = calculateGRA(values);\n          break;\n        case \"CITC\":\n          results[key][typeKey] = calculateCITC(values);\n          break;\n        case \"GCITC\":\n          results[key][typeKey] = calculateGCITC(values);\n          break;\n        case \"RACITC\":\n          results[key][typeKey] = calculateRACITC(values);\n          break;\n        case \"NA\":\n          results[key][typeKey] = calculateNA(values);\n          break;\n      }\n    });\n  });\n\n  return results;\n}\n\nconst additionalMileage = calculateAdditionalMileage(categorizedKeys);\nconsole.log(\"muh additionalMileage\", additionalMileage);\n\n// This extracts the e.g [153,39,39,51,0,0]\nfunction extractFrequencyByDayType(categorizedKeys) {\n  const results = {};\n\n  // Iterate over each contract in sortedKeys\n  Object.keys(categorizedKeys).forEach((contractKey) => {\n    const services = categorizedKeys[contractKey];\n    results[contractKey] = {};\n\n    // Iterate over each service in the contract\n    Object.keys(services).forEach((serviceKey) => {\n      // Directly access the 'values' array from the provided structure\n      const serviceValues = services[serviceKey].values;\n\n      // Check if 'values' exists and has elements\n      if (serviceValues && serviceValues.length > 0) {\n        // Assuming we want to capture the entire 'implementationPeriod' data for the service\n        const implementationPeriodData =\n          serviceValues[0].implementationPeriod.map((period) => {\n            return period[1];\n          });\n\n        // Store the collected implementation period data under the original service key\n        results[contractKey][serviceKey] = implementationPeriodData;\n      }\n    });\n  });\n\n  return results;\n}\n\nconst frequencyByDayType = extractFrequencyByDayType(categorizedKeys);\nconsole.log(\"muh frequencyByDayType\", frequencyByDayType);\n\n// For calculating Dates, noOfBus, unitCosts, grandTotal\nfunction calculateLeaseFeeDetails(categorizedKeys) {\n  const results = {};\n\n  Object.entries(categorizedKeys).forEach(([categoryKey, services]) => {\n    results[categoryKey] = {};\n\n    Object.entries(services).forEach(([serviceKey, serviceDetails]) => {\n      const transactionDetails = [];\n      let grandTotal = new bigDecimal(0);\n\n      // Process only if isMatch is true or onlyBusFleet is true\n      if (\n        serviceDetails.isMatch === true ||\n        serviceDetails.onlyBusFleet === true\n      ) {\n        const transactions = serviceDetails.BusFleet\n          ? serviceDetails.BusFleet.Transaction\n          : serviceDetails.Transaction;\n\n        for (const key in transactions) {\n          const transaction = transactions[key];\n          // Calculate unit and total costs\n          let unitCost = new bigDecimal(transaction[2]);\n          let totalUnitCost = new bigDecimal(transaction[1]).multiply(unitCost);\n          grandTotal = grandTotal.add(totalUnitCost);\n\n          transactionDetails.push({\n            Transaction: key,\n            \"Handover/Return Date\": formatDateForTransactions(transaction[0]),\n            \"No. of Buses\": transaction[1],\n            \"Unit Cost\": unitCost.getValue(),\n            \"Total Unit Cost\": totalUnitCost.getValue(),\n          });\n        }\n\n        // Store the computed details in the results\n        results[categoryKey][serviceKey] = {\n          grandTotal: grandTotal.getValue(),\n          transactions: transactionDetails,\n        };\n      }\n     \n    });\n  });\n\n  return results;\n}\n\nconst leaseFeeDetails = calculateLeaseFeeDetails(categorizedKeys);\nconsole.log(\"muh report #1 leaseFee\", leaseFeeDetails);\n\n\nfunction calculateFirstReportData(categorizedKeys, additionalMileage, frequencyByDayType, leaseFeeDetails) {\n  let results = {};\n  const inflationRate = new bigDecimal(1.02); // 2% Inflation Rate\n  const baseUnitRate = new bigDecimal(BusData.body.unitRate); // Base Unit Rate\n  const fuelRate = new bigDecimal(BusData.body.fuelRate); // Fuel Rate\n\n  Object.keys(categorizedKeys).forEach((contractNumber) => {\n    results[contractNumber] = {};\n\n    Object.keys(categorizedKeys[contractNumber]).forEach((uniqueKey) => {\n      results[contractNumber][uniqueKey] = [];\n\n      let periods = categorizedKeys[contractNumber][uniqueKey].values[0].implementationPeriod;\n      let currentUnitRate = baseUnitRate;\n\n      periods.forEach((periodPair, index) => {\n        currentUnitRate = index > 0 ? currentUnitRate.multiply(inflationRate).round(2, bigDecimal.RoundingModes.HALF_UP) : currentUnitRate;\n\n        const [periodDateStart, periodDateEnd] = periodPair[0].split(\"-\");\n        const periodEndYear = periodPair[0].slice(-4)\n        const dayJSPeriodDateStart = formatDateDayJS(periodDateStart);\n        const dayJSPeriodDateEnd = formatDateDayJS(periodDateEnd);\n        const dayJSPeriodDateEndForDateDiff = dayjs(dayJSPeriodDateEnd).add(1, \"day\").format(\"YYYY-MM-DD\");\n        const periodDateDiff = new bigDecimal(dayjs(dayJSPeriodDateEndForDateDiff).diff(dayjs(dayJSPeriodDateStart), \"month\", true)).round(2, bigDecimal.RoundingModes.HALF_UP);\n\n        // For First Period Lease Fee Calculation\n        // First Period Lease Fee  Logic: Compare Handover/ReturnDate with 1st Period's \"Duration TO\" then multiply totalUnitCost E.g: DiesalSD: [190224, 3, 100] -> (3 * 100 = 300).\n        let firstPeriodLeaseFeeCalculation = new bigDecimal(0);\n        if (index === 0 && leaseFeeDetails[contractNumber] && leaseFeeDetails[contractNumber][uniqueKey]) {\n          console.log(`- Calculating for contract: ${contractNumber}, service: ${uniqueKey}`);\n          leaseFeeDetails[contractNumber][uniqueKey].transactions.forEach((transaction, transactionIndex) => {\n            const transactionDate = formatLeaseFeeDetailsDateDayJS(transaction[\"Handover/Return Date\"]);\n            const dateDiff = new bigDecimal(dayjs(dayJSPeriodDateEndForDateDiff).diff(dayjs(transactionDate), \"month\", true)).round(2, bigDecimal.RoundingModes.HALF_UP);\n            const totalUnitCost = new bigDecimal(transaction[\"Total Unit Cost\"]);\n            const transactionLeaseFee = totalUnitCost.multiply(dateDiff).round(2, bigDecimal.RoundingModes.HALF_UP);\n            firstPeriodLeaseFeeCalculation = firstPeriodLeaseFeeCalculation.add(transactionLeaseFee);\n\n            // How to check firstPeriodLeaseFeeCalculation 101 (dont modify or remove this):\n            // 1. Use \"-\" in console search bar\n            // 2. Check difference of(transactionDate & dayJSPeriodDateEndForDateDiff) == dateDiff\n            // 3. Check if totalUnitCost is correct in Transaction. E.g: DiesalSD: [190224, 3, 100] -> (3 * 100 = 300).\n            // 4. Check if transactionLeaseFee = diffDiff * totalUnitCost\n            // 5. Check firstPeriodLeaseFeeCalculation has added all transactionLeaseFee*S* (with a S because there can be multiple Transactions)\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction #${transactionIndex + 1} (${transaction[\"Transaction\"]}) Details:`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction Date: ${transactionDate}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Lease Fee Date End (+1 day offset): ${dayJSPeriodDateEndForDateDiff}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Date Difference (Months): ${dateDiff.getValue()}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Total Unit Cost: ${totalUnitCost.getValue()}`);\n            // prettier-ignore\n            console.log(`[${contractNumber}][${uniqueKey}] - Transaction Lease Fee: ${transactionLeaseFee.getValue()}`);\n          });\n          // prettier-ignore\n          console.log(`[${contractNumber}][${uniqueKey}] - First Period Lease Fee Calculation Total: ${firstPeriodLeaseFeeCalculation.getValue()}`);\n        }\n        let periodMileage = new bigDecimal(0);\n        if (frequencyByDayType[contractNumber] && frequencyByDayType[contractNumber][uniqueKey] && additionalMileage[contractNumber] && additionalMileage[contractNumber][uniqueKey]) {\n          let freqArray = JSON.parse(frequencyByDayType[contractNumber][uniqueKey][index]);\n          let additional = additionalMileage[contractNumber][uniqueKey];\n          periodMileage = freqArray.reduce((sum, freq, idx) => sum.add(new bigDecimal(freq).multiply(new bigDecimal(additional[idx]))), new bigDecimal(0));\n        }\n\n        const YearlySF = periodMileage.multiply(currentUnitRate).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const fuelCost = periodMileage.multiply(fuelRate).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const periodUnitRFuelR = currentUnitRate.add(fuelRate);\n        const periodSfCost = YearlySF.add(fuelCost);\n        const grandTotal = leaseFeeDetails[contractNumber] && leaseFeeDetails[contractNumber][uniqueKey] ? new bigDecimal(leaseFeeDetails[contractNumber][uniqueKey].grandTotal) : new bigDecimal(0);\n        const periodLeaseFee = index === 0 ? firstPeriodLeaseFeeCalculation : periodDateDiff.multiply(grandTotal).round(2, bigDecimal.RoundingModes.HALF_UP);\n        const periodTotalCost = periodLeaseFee.add(periodSfCost);\n\n        results[contractNumber][uniqueKey].push({\n          endYear: periodEndYear,\n          dayJSPeriodDateStart: dayJSPeriodDateStart,\n          dayJSPeriodDateEnd: dayJSPeriodDateEnd,\n          dateStart: formatDateForDuration(dayJSPeriodDateStart),\n          dateEnd: formatDateForDuration(dayJSPeriodDateEnd),\n          mileage: periodMileage.getValue(),\n          unitRate: currentUnitRate.getValue(),\n          YearlySF: YearlySF.getValue(),\n          fuelRate: fuelRate.getValue(),\n          fuelCost: fuelCost.getValue(),\n          UnitRFuelR: periodUnitRFuelR.getValue(),\n          sfCost: periodSfCost.getValue(),\n          dateDiff: periodDateDiff.getValue(),\n          leaseFee: periodLeaseFee.getValue(),\n          totalCost: periodTotalCost.getValue(),\n          unitCostTotal: grandTotal.getValue(),\n        });\n      });\n    });\n  });\n\n  return results;\n}\n\nconst FirstReportData = calculateFirstReportData(\n  categorizedKeys,\n  additionalMileage,\n  frequencyByDayType,\n  leaseFeeDetails\n);\nconsole.log(\"muh report #1 data\", FirstReportData);\n\nfunction calculateTotalData() {\n  const result = {};\n\n  // Calculate Frequency By Day Type Totals\n  for (const contract in frequencyByDayType) {\n    result[contract] = result[contract] || {};\n\n    for (const service in frequencyByDayType[contract]) {\n      const dataArrays = frequencyByDayType[contract][service].map((str) =>\n        JSON.parse(str)\n      );\n      result[contract][service] = {\n        MonToThurs: dataArrays.reduce((sum, arr) => sum + arr[0], 0),\n        Friday: dataArrays.reduce((sum, arr) => sum + arr[1], 0),\n        Saturdays: dataArrays.reduce((sum, arr) => sum + arr[2], 0),\n        Sundays: dataArrays.reduce((sum, arr) => sum + arr[3], 0),\n        SchHoliday: dataArrays.reduce((sum, arr) => sum + arr[4], 0),\n        Others: dataArrays.reduce((sum, arr) => sum + arr[5], 0),\n      };\n    }\n  }\n  // Loop through each contract in FirstReportData\n  for (const contract in FirstReportData) {\n    result[contract] = result[contract] || {};\n\n    // Loop through each service in the contract\n    for (const service in FirstReportData[contract]) {\n      let year = new bigDecimal(365);\n      let totalMileage = new bigDecimal(0);\n      let totalYearlySF = new bigDecimal(0);\n      let totalFuelCost = new bigDecimal(0);\n      let totalSfCost = new bigDecimal(0);\n      let totalCost = new bigDecimal(0);\n      let annualMileage = new bigDecimal(0);\n      let annualSF = new bigDecimal(0);\n      let annualLF = new bigDecimal(0);\n      let annualCost = new bigDecimal(0);\n      let annualCostCrr = new bigDecimal(0);\n      const tripCountSum = Object.values(\n        result[contract][service] || {}\n      ).reduce((sum, count) => sum + count, 0);\n      const firstUnitRateFuelRate = parseFloat(\n        FirstReportData[contract][service].find((data) => data.UnitRFuelR)\n          ?.UnitRFuelR || 0\n      );\n      const monthlyLF = parseFloat(\n        FirstReportData[contract][service].find((data) => data.unitCostTotal)\n          ?.unitCostTotal || 0\n      );\n      const voStartDate =\n        FirstReportData[contract][service][0]?.dayJSPeriodDateStart ||\n        \"error-retriving-date\";\n      const voEndDate =\n        FirstReportData[contract][service][\n          FirstReportData[contract][service].length - 1\n        ]?.dayJSPeriodDateEnd || \"error-retriving-date\";\n\n      FirstReportData[contract][service].forEach((period) => {\n        totalMileage = totalMileage.add(new bigDecimal(period.mileage || 0));\n        totalYearlySF = totalYearlySF.add(new bigDecimal(period.YearlySF || 0));\n        totalFuelCost = totalFuelCost.add(new bigDecimal(period.fuelCost || 0));\n        totalSfCost = totalSfCost.add(new bigDecimal(period.sfCost || 0));\n        totalCost = totalCost.add(new bigDecimal(period.totalCost || 0));\n      });\n\n      // Check if tripCountSum is 0 to avoid division by zero error; tripCountSum is 0 when NA conditions (onlyBusFleet=True).\n      if (tripCountSum === 0) {\n        annualMileage = new bigDecimal(0);\n      } else {\n        // Proceed with the division if tripCountSum is not 0\n        annualMileage = totalMileage\n          .divide(new bigDecimal(tripCountSum))\n          .multiply(year);\n      }\n\n      let numericTotalCost = parseFloat(totalCost.getValue());\n      annualSF = annualMileage\n        .multiply(new bigDecimal(firstUnitRateFuelRate))\n        .round(2, bigDecimal.RoundingModes.HALF_UP)\n        .getValue();\n      annualLF = new bigDecimal(monthlyLF)\n        .multiply(new bigDecimal(12))\n        .round(2, bigDecimal.RoundingModes.HALF_UP)\n        .getValue();\n      annualCost = new bigDecimal(annualSF)\n        .add(new bigDecimal(annualLF))\n        .round(2, bigDecimal.RoundingModes.HALF_UP)\n        .getValue();\n\n      result[contract][service] = {\n        ...result[contract][service],\n        totalMileage: totalMileage\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        totalYearlySF: totalYearlySF\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        totalFuelCost: totalFuelCost\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        totalSfCost: totalSfCost\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        totalCost: totalCost\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        totalAmountReq: roundGrandTotal1000(numericTotalCost).toString(),\n        annualMileage: annualMileage\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n        annualSF: annualSF,\n        annualLF: annualLF,\n        annualCost: annualCost,\n        voStartDate: formatDateForVO(voStartDate),\n        voEndDate: formatDateForVO(voEndDate),\n        annualCostCrr: annualCostCrr\n          .round(2, bigDecimal.RoundingModes.HALF_UP)\n          .getValue(),\n      };\n    }\n  }\n\n  return result;\n}\nconst totalFirstReportData = calculateTotalData();\nconsole.log(\"muh report #1 total data\", totalFirstReportData);\n\nexport {\n  findServiceData,\n  checkedValues,\n  categorizedKeys,\n  sortedKeys,\n  additionalMileage,\n  frequencyByDayType,\n  leaseFeeDetails,\n  FirstReportData,\n  totalFirstReportData,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}